'use strict'
// wrapper around mkdirp for tar's needs.

// TODO: This should probably be a class, not functionally
// passing around state in a gazillion args.

const mkdirp = require('mkdirp')
const fs = require('fs')
const path = require('path')
const chownr = require('chownr')
<<<<<<< HEAD
=======
const normPath = require('./normalize-windows-path.js')
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf

class SymlinkError extends Error {
  constructor (symlink, path) {
    super('Cannot extract through symbolic link')
    this.path = path
    this.symlink = symlink
  }

  get name () {
    return 'SylinkError'
  }
}

class CwdError extends Error {
  constructor (path, code) {
    super(code + ': Cannot cd into \'' + path + '\'')
    this.path = path
    this.code = code
  }

  get name () {
    return 'CwdError'
  }
}

<<<<<<< HEAD
module.exports = (dir, opt, cb) => {
=======
const cGet = (cache, key) => cache.get(normPath(key))
const cSet = (cache, key, val) => cache.set(normPath(key), val)

const checkCwd = (dir, cb) => {
  fs.stat(dir, (er, st) => {
    if (er || !st.isDirectory())
      er = new CwdError(dir, er && er.code || 'ENOTDIR')
    cb(er)
  })
}

module.exports = (dir, opt, cb) => {
  dir = normPath(dir)

>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    (uid !== opt.processUid || gid !== opt.processGid)

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
<<<<<<< HEAD
  const cwd = opt.cwd
=======
  const cwd = normPath(opt.cwd)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf

  const done = (er, created) => {
    if (er)
      cb(er)
    else {
<<<<<<< HEAD
      cache.set(dir, true)
=======
      cSet(cache, dir, true)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
      if (created && doChown)
        chownr(created, uid, gid, er => done(er))
      else if (needChmod)
        fs.chmod(dir, mode, cb)
      else
        cb()
    }
  }

<<<<<<< HEAD
  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd) {
    return fs.stat(dir, (er, st) => {
      if (er || !st.isDirectory())
        er = new CwdError(dir, er && er.code || 'ENOTDIR')
      done(er)
    })
  }
=======
  if (cache && cGet(cache, dir) === true)
    return done()

  if (dir === cwd)
    return checkCwd(dir, done)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf

  if (preserve)
    return mkdirp(dir, {mode}).then(made => done(null, made), done)

<<<<<<< HEAD
  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
=======
  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)
}

const mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {
  if (!parts.length)
    return cb(null, created)
  const p = parts.shift()
<<<<<<< HEAD
  const part = base + '/' + p
  if (cache.get(part))
=======
  const part = normPath(path.resolve(base + '/' + p))
  if (cGet(cache, part))
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
}

const onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {
  if (er) {
<<<<<<< HEAD
    if (er.path && path.dirname(er.path) === cwd &&
        (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
      return cb(new CwdError(cwd, er.code))

    fs.lstat(part, (statEr, st) => {
      if (statEr)
        cb(statEr)
      else if (st.isDirectory())
=======
    fs.lstat(part, (statEr, st) => {
      if (statEr) {
        statEr.path = statEr.path && normPath(statEr.path)
        cb(statEr)
      } else if (st.isDirectory())
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
      else if (unlink) {
        fs.unlink(part, er => {
          if (er)
            return cb(er)
          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))
        })
      } else if (st.isSymbolicLink())
        return cb(new SymlinkError(part, part + '/' + parts.join('/')))
      else
        cb(er)
    })
  } else {
    created = created || part
    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)
  }
}

<<<<<<< HEAD
module.exports.sync = (dir, opt) => {
=======
const checkCwdSync = dir => {
  let ok = false
  let code = 'ENOTDIR'
  try {
    ok = fs.statSync(dir).isDirectory()
  } catch (er) {
    code = er.code
  } finally {
    if (!ok)
      throw new CwdError(dir, code)
  }
}

module.exports.sync = (dir, opt) => {
  dir = normPath(dir)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
  // if there's any overlap between mask and mode,
  // then we'll need an explicit chmod
  const umask = opt.umask
  const mode = opt.mode | 0o0700
  const needChmod = (mode & umask) !== 0

  const uid = opt.uid
  const gid = opt.gid
  const doChown = typeof uid === 'number' &&
    typeof gid === 'number' &&
    (uid !== opt.processUid || gid !== opt.processGid)

  const preserve = opt.preserve
  const unlink = opt.unlink
  const cache = opt.cache
<<<<<<< HEAD
  const cwd = opt.cwd

  const done = (created) => {
    cache.set(dir, true)
=======
  const cwd = normPath(opt.cwd)

  const done = (created) => {
    cSet(cache, dir, true)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
    if (created && doChown)
      chownr.sync(created, uid, gid)
    if (needChmod)
      fs.chmodSync(dir, mode)
  }

<<<<<<< HEAD
  if (cache && cache.get(dir) === true)
    return done()

  if (dir === cwd) {
    let ok = false
    let code = 'ENOTDIR'
    try {
      ok = fs.statSync(dir).isDirectory()
    } catch (er) {
      code = er.code
    } finally {
      if (!ok)
        throw new CwdError(dir, code)
    }
    done()
    return
=======
  if (cache && cGet(cache, dir) === true)
    return done()

  if (dir === cwd) {
    checkCwdSync(cwd)
    return done()
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
  }

  if (preserve)
    return done(mkdirp.sync(dir, mode))

<<<<<<< HEAD
  const sub = path.relative(cwd, dir)
  const parts = sub.split(/\/|\\/)
=======
  const sub = normPath(path.relative(cwd, dir))
  const parts = sub.split('/')
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
  let created = null
  for (let p = parts.shift(), part = cwd;
    p && (part += '/' + p);
    p = parts.shift()) {
<<<<<<< HEAD
    if (cache.get(part))
=======
    part = normPath(path.resolve(part))
    if (cGet(cache, part))
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
      continue

    try {
      fs.mkdirSync(part, mode)
      created = created || part
<<<<<<< HEAD
      cache.set(part, true)
    } catch (er) {
      if (er.path && path.dirname(er.path) === cwd &&
          (er.code === 'ENOTDIR' || er.code === 'ENOENT'))
        return new CwdError(cwd, er.code)

      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cache.set(part, true)
=======
      cSet(cache, part, true)
    } catch (er) {
      const st = fs.lstatSync(part)
      if (st.isDirectory()) {
        cSet(cache, part, true)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
        continue
      } else if (unlink) {
        fs.unlinkSync(part)
        fs.mkdirSync(part, mode)
        created = created || part
<<<<<<< HEAD
        cache.set(part, true)
=======
        cSet(cache, part, true)
>>>>>>> ea2b82f34611564aa63c259c196ff2c6da8839bf
        continue
      } else if (st.isSymbolicLink())
        return new SymlinkError(part, part + '/' + parts.join('/'))
    }
  }

  return done(created)
}
